[{"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\index.js":"1","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\reportWebVitals.js":"2","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\App.js":"3","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\sortingAlgorithms.js":"4"},{"size":517,"mtime":1612131202661,"results":"5","hashOfConfig":"6"},{"size":375,"mtime":1612131202662,"results":"7","hashOfConfig":"6"},{"size":5269,"mtime":1615515002999,"results":"8","hashOfConfig":"6"},{"size":5181,"mtime":1615444450229,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"14i9blu",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"12"},"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\index.js",[],["20","21"],"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\reportWebVitals.js",[],"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\App.js",["22","23"],"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\sortingAlgorithms.js",["24"],"// HELPER FUNCTIONS\r\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations,) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n}\r\n\r\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n\r\n    while (i <= middleIdx && j <= endIdx) {\r\n        // Values that are being compared; Add to animations to change their color.\r\n        animations.push([i, j]);\r\n        // Values that are being compared; Add to animations to revert their color.\r\n        animations.push([i, j]);\r\n\r\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n            // Overwrite value at index k in the original array with the value at index i in the auxiliary array.\r\n            animations.push([k, auxiliaryArray[i]]);\r\n            mainArray[k++] = auxiliaryArray[i++];\r\n        } else {\r\n            // Overwrite the value at index k in the original array with the value at index j in the auxiliary array.\r\n            animations.push([k, auxiliaryArray[j]]);\r\n            mainArray[k++] = auxiliaryArray[j++];\r\n        }\r\n    }\r\n    while (i <= middleIdx) {\r\n        // Values that are being compared; Add to animations to change their color.\r\n        animations.push([i, i]);\r\n        // Values that are being compared; Add to animations to revert their color.\r\n        animations.push([i, i]);\r\n        // Overwrite the value at index k in the original array with the value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n        // Values that are being compared; Add to animations to change their color.\r\n        animations.push([j, j]);\r\n        // Values that are being compared; Add to animations to revert their color.\r\n        animations.push([j, j]);\r\n        // Overwrite the value at index k in the original array with the value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n}\r\n\r\nfunction heapify(arr, n, i, animations) {\r\n    // Find highest value between root, left, and right in tree\r\n    let highest = i;            //index\r\n    const left = 2 * i + 1;     //index\r\n    const right = 2 * i + 2;    //index\r\n\r\n    animations.push([i, left]);\r\n    if (left < n && arr[left] > arr[highest]){\r\n        highest = left;\r\n    }\r\n    animations.push([i, left]);\r\n\r\n    animations.push([i, right]);\r\n    if (right < n && arr[right] > arr[highest]){\r\n        highest = right;\r\n    }\r\n    animations.push([i, right]);\r\n\r\n    if (highest !== i){\r\n        arr = swap(arr, arr[i], arr[highest], animations);\r\n        heapify(arr, n, highest, animations);\r\n    }\r\n\r\n    console.log(arr);\r\n}\r\n\r\n// EXPORTED FUNCTIONS\r\nfunction getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n}\r\n\r\nfunction getBubbleSortAnimations(array) {\r\n    const animations = [];\r\n    let len = array.length;\r\n\r\n    if (len <= 1) return array;\r\n\r\n    for (let i = 0; i < len - 1; i++) {\r\n        for (let j = 0; j < len - 1; j++) {\r\n            animations.push([j, j + 1]);\r\n            animations.push([j, j + 1]);\r\n\r\n            if (array[j] > array[j + 1]) {\r\n                let val1 = array[j];\r\n                let val2 = array[j + 1];\r\n\r\n                animations.push([j, val2]);\r\n                animations.push([j + 1, val1]);\r\n\r\n                let tmp = array[j];\r\n                array[j] = array[j + 1];\r\n                array[j + 1] = tmp;\r\n            }\r\n            else {\r\n                animations.push([j, array[j]]);\r\n                animations.push([j + 1, array[j + 1]]);\r\n            }\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n\r\nfunction getHeapSortAnimations(arr) {\r\n    let animations = [];\r\n\r\n    // arr.length / 2 - 1 is the last index that will be the parent of a tree\r\n    for(let i = arr.length / 2 - 1; i >= 0; i--){\r\n        heapify(arr, arr.length, i, animations);\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\nfunction swap(arr, i, i2, animations){\r\n    let tmp = arr[i]\r\n    arr[i] = arr[i2];\r\n    arr[i2] = tmp;\r\n\r\n    return arr;\r\n}\r\n\r\nexport default { getBubbleSortAnimations, getMergeSortAnimations, getHeapSortAnimations }\r\n\r\n// let bubbleSort = (inputArr) => {\r\n//     let len = inputArr.length;\r\n//     for (let i = 0; i < len; i++) {\r\n//         for (let j = 0; j < len; j++) {\r\n//             if (inputArr[j] > inputArr[j + 1]) {\r\n//                 let tmp = inputArr[j];\r\n//                 inputArr[j] = inputArr[j + 1];\r\n//                 inputArr[j + 1] = tmp;\r\n//             }\r\n//         }\r\n//     }\r\n//     return inputArr;\r\n// };",{"ruleId":"25","replacedBy":"26"},{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","severity":1,"message":"30","line":129,"column":11,"nodeType":"31","messageId":"32","endLine":129,"endColumn":20},{"ruleId":"29","severity":1,"message":"33","line":130,"column":11,"nodeType":"31","messageId":"32","endLine":130,"endColumn":21},{"ruleId":"34","severity":1,"message":"35","line":136,"column":1,"nodeType":"36","endLine":136,"endColumn":90},"no-native-reassign",["37"],"no-negated-in-lhs",["38"],"no-unused-vars","'arrayBars' is assigned a value but never used.","Identifier","unusedVar","'animations' is assigned a value but never used.","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]
[{"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\index.js":"1","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\reportWebVitals.js":"2","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\App.js":"3","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\sortingAlgorithms.js":"4"},{"size":509,"mtime":1615762250545,"results":"5","hashOfConfig":"6"},{"size":375,"mtime":1612131202662,"results":"7","hashOfConfig":"8"},{"size":5344,"mtime":1616348538788,"results":"9","hashOfConfig":"6"},{"size":5181,"mtime":1615444450229,"results":"10","hashOfConfig":"6"},{"filePath":"11","messages":"12","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"13"},"1qazr4b",{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"14i9blu",{"filePath":"17","messages":"18","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"13"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\index.js",[],["23","24"],"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\reportWebVitals.js",[],["25","26"],"C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\App.js",["27","28"],"import { useState } from 'react';\r\nimport './styles/css/App.css';\r\nimport sortingAlgorithms from './sortingAlgorithms.js'\r\n\r\n// Change this value for the speed of the animations.\r\nconst ANIMATION_SPEED_MS = 5;\r\n\r\n// Change this value for the number of bars (value) in the array.\r\nconst NUMBER_OF_ARRAY_BARS = 100;\r\n\r\n// This is the main color of the array bars.\r\nconst PRIMARY_COLOR = 'turquoise';\r\n\r\n// This is the color of array bars that are being compared throughout the animations.\r\nconst SECONDARY_COLOR = 'red';\r\n\r\n// This is the lowest value that should be in the array.\r\nconst MIN_VALUE = 1;\r\n\r\n// This is the highest value that should be in the array. Dictates the height of the different bars.\r\nconst MAX_VALUE = 1000;\r\n\r\n// Initial array of values to eventually be sorted\r\nlet myValues = initArray;\r\n\r\nfunction getRandomInt(min, max) { // Get a random number between specified values\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nfunction initArray() {\r\n  let arr = [];\r\n\r\n  for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\r\n    arr.push(getRandomInt(MIN_VALUE, MAX_VALUE));\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\nfunction App() {\r\n  let [values, setValues] = useState(myValues);\r\n  let [isProcessing, setProcessingState] = useState(false);\r\n\r\n  function handleNewArray() {\r\n    setValues(initArray);\r\n  }\r\n\r\n  function handleMergeSort() {\r\n    setProcessingState(true);\r\n    const animations = sortingAlgorithms.getMergeSortAnimations(values);\r\n\r\n    for (let i = 0; i < animations.length; i++) {\r\n      const arrayBars = document.getElementsByClassName('array-bar');\r\n      const isColorChange = i % 3 !== 2;\r\n\r\n      if (isColorChange) {\r\n        const [barOneIdx, barTwoIdx] = animations[i];\r\n        const barOneStyle = arrayBars[barOneIdx].style;\r\n        const barTwoStyle = arrayBars[barTwoIdx].style;\r\n        const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n\r\n        setTimeout(() => {\r\n          barOneStyle.backgroundColor = color;\r\n          barTwoStyle.backgroundColor = color;\r\n\r\n          if (i === animations.length - 1) {\r\n            setProcessingState(false);\r\n          }\r\n        }, i * ANIMATION_SPEED_MS);\r\n      } else {\r\n        setTimeout(() => {\r\n          const [barOneIdx, newHeight] = animations[i];\r\n          const barOneStyle = arrayBars[barOneIdx].style;\r\n          barOneStyle.height = (100 / MAX_VALUE) * newHeight + '%';\r\n\r\n          if (i === animations.length - 1) {\r\n            setProcessingState(false);\r\n          }\r\n        }, i * ANIMATION_SPEED_MS);\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleBubbleSort() {\r\n    const animations = sortingAlgorithms.getBubbleSortAnimations(values);\r\n    let cnt = 1;\r\n\r\n    for (let i = 0; i < animations.length; i++) {\r\n      const arrayBars = document.getElementsByClassName('array-bar');\r\n      const [barOneIdx, barTwoIdx] = animations[i];\r\n\r\n      let color = i % 2 !== 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n      let isNotColorChange = ((cnt) % 3 === 0 && ((cnt)) % 4 !== 2) || (cnt) % 4 === 0;\r\n      let isColorChange = !isNotColorChange;\r\n\r\n      if (isColorChange) {\r\n        const barOneStyle = arrayBars[barOneIdx].style;\r\n        const barTwoStyle = arrayBars[barTwoIdx].style;\r\n\r\n        if (cnt % 2 === 0) {\r\n          color = PRIMARY_COLOR\r\n        } else {\r\n          color = SECONDARY_COLOR\r\n        }\r\n\r\n        setTimeout(() => {\r\n          barOneStyle.backgroundColor = color;\r\n          barTwoStyle.backgroundColor = color;\r\n        }, i * ANIMATION_SPEED_MS);\r\n      } else {\r\n        setTimeout(() => {\r\n          const [barOneIdx, newHeight] = animations[i];\r\n          const barOneStyle = arrayBars[barOneIdx].style;\r\n          barOneStyle.height = (100 / MAX_VALUE) * newHeight + '%';\r\n        }, i * ANIMATION_SPEED_MS);\r\n      }\r\n\r\n      if (cnt < 4) {\r\n        cnt++;\r\n      } else {\r\n        cnt = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleHeapSort() {\r\n    const arrayBars = document.getElementsByClassName('array-bar');\r\n    const animations = sortingAlgorithms.getHeapSortAnimations(values);\r\n  }\r\n\r\n  return (\r\n    <div className='App'>\r\n      <header className='App-header'>\r\n        <h1>\r\n          Sorting Algorithms Visualiser\r\n        </h1>\r\n\r\n        <h3>\r\n          Using <a href='https://reactjs.org/' target='_blank' rel='noreferrer'>React</a>\r\n        </h3>\r\n      </header>\r\n\r\n      <section className='inputs'>\r\n        <input type='button' onClick={handleNewArray} value='New Array' disabled={isProcessing} />\r\n        <input type='button' onClick={handleMergeSort} value='Merge Sort' disabled={isProcessing} />\r\n        <input type='button' onClick={handleBubbleSort} value='Bubble Sort' disabled={isProcessing} />\r\n        <input type='button' onClick={handleHeapSort} value='Heap Sort' disabled={isProcessing} />\r\n      </section>\r\n\r\n      <section className='bars'>\r\n        <div className='bar-wrapper'>\r\n          {values.map((value, idx) => (\r\n            <div\r\n              className='array-bar'\r\n              key={idx}\r\n              style={{\r\n                backgroundColor: PRIMARY_COLOR,\r\n                height: (100 / MAX_VALUE) * value + '%',\r\n                width: 100 / values.length + '%'\r\n              }}></div>\r\n          ))}\r\n        </div>\r\n      </section>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","C:\\Users\\Kaleb\\OneDrive\\Documents\\GitHub\\react-sorting\\src\\sortingAlgorithms.js",["29"],"// HELPER FUNCTIONS\r\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations,) {\r\n    if (startIdx === endIdx) return;\r\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n}\r\n\r\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\r\n    let k = startIdx;\r\n    let i = startIdx;\r\n    let j = middleIdx + 1;\r\n\r\n    while (i <= middleIdx && j <= endIdx) {\r\n        // Values that are being compared; Add to animations to change their color.\r\n        animations.push([i, j]);\r\n        // Values that are being compared; Add to animations to revert their color.\r\n        animations.push([i, j]);\r\n\r\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n            // Overwrite value at index k in the original array with the value at index i in the auxiliary array.\r\n            animations.push([k, auxiliaryArray[i]]);\r\n            mainArray[k++] = auxiliaryArray[i++];\r\n        } else {\r\n            // Overwrite the value at index k in the original array with the value at index j in the auxiliary array.\r\n            animations.push([k, auxiliaryArray[j]]);\r\n            mainArray[k++] = auxiliaryArray[j++];\r\n        }\r\n    }\r\n    while (i <= middleIdx) {\r\n        // Values that are being compared; Add to animations to change their color.\r\n        animations.push([i, i]);\r\n        // Values that are being compared; Add to animations to revert their color.\r\n        animations.push([i, i]);\r\n        // Overwrite the value at index k in the original array with the value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n    }\r\n    while (j <= endIdx) {\r\n        // Values that are being compared; Add to animations to change their color.\r\n        animations.push([j, j]);\r\n        // Values that are being compared; Add to animations to revert their color.\r\n        animations.push([j, j]);\r\n        // Overwrite the value at index k in the original array with the value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n}\r\n\r\nfunction heapify(arr, n, i, animations) {\r\n    // Find highest value between root, left, and right in tree\r\n    let highest = i;            //index\r\n    const left = 2 * i + 1;     //index\r\n    const right = 2 * i + 2;    //index\r\n\r\n    animations.push([i, left]);\r\n    if (left < n && arr[left] > arr[highest]){\r\n        highest = left;\r\n    }\r\n    animations.push([i, left]);\r\n\r\n    animations.push([i, right]);\r\n    if (right < n && arr[right] > arr[highest]){\r\n        highest = right;\r\n    }\r\n    animations.push([i, right]);\r\n\r\n    if (highest !== i){\r\n        arr = swap(arr, arr[i], arr[highest], animations);\r\n        heapify(arr, n, highest, animations);\r\n    }\r\n\r\n    console.log(arr);\r\n}\r\n\r\n// EXPORTED FUNCTIONS\r\nfunction getMergeSortAnimations(array) {\r\n    const animations = [];\r\n    if (array.length <= 1) return array;\r\n    const auxiliaryArray = array.slice();\r\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n    return animations;\r\n}\r\n\r\nfunction getBubbleSortAnimations(array) {\r\n    const animations = [];\r\n    let len = array.length;\r\n\r\n    if (len <= 1) return array;\r\n\r\n    for (let i = 0; i < len - 1; i++) {\r\n        for (let j = 0; j < len - 1; j++) {\r\n            animations.push([j, j + 1]);\r\n            animations.push([j, j + 1]);\r\n\r\n            if (array[j] > array[j + 1]) {\r\n                let val1 = array[j];\r\n                let val2 = array[j + 1];\r\n\r\n                animations.push([j, val2]);\r\n                animations.push([j + 1, val1]);\r\n\r\n                let tmp = array[j];\r\n                array[j] = array[j + 1];\r\n                array[j + 1] = tmp;\r\n            }\r\n            else {\r\n                animations.push([j, array[j]]);\r\n                animations.push([j + 1, array[j + 1]]);\r\n            }\r\n        }\r\n    }\r\n    return animations;\r\n}\r\n\r\nfunction getHeapSortAnimations(arr) {\r\n    let animations = [];\r\n\r\n    // arr.length / 2 - 1 is the last index that will be the parent of a tree\r\n    for(let i = arr.length / 2 - 1; i >= 0; i--){\r\n        heapify(arr, arr.length, i, animations);\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\nfunction swap(arr, i, i2, animations){\r\n    let tmp = arr[i]\r\n    arr[i] = arr[i2];\r\n    arr[i2] = tmp;\r\n\r\n    return arr;\r\n}\r\n\r\nexport default { getBubbleSortAnimations, getMergeSortAnimations, getHeapSortAnimations }\r\n\r\n// let bubbleSort = (inputArr) => {\r\n//     let len = inputArr.length;\r\n//     for (let i = 0; i < len; i++) {\r\n//         for (let j = 0; j < len; j++) {\r\n//             if (inputArr[j] > inputArr[j + 1]) {\r\n//                 let tmp = inputArr[j];\r\n//                 inputArr[j] = inputArr[j + 1];\r\n//                 inputArr[j + 1] = tmp;\r\n//             }\r\n//         }\r\n//     }\r\n//     return inputArr;\r\n// };",{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},{"ruleId":"30","replacedBy":"34"},{"ruleId":"32","replacedBy":"35"},{"ruleId":"36","severity":1,"message":"37","line":129,"column":11,"nodeType":"38","messageId":"39","endLine":129,"endColumn":20},{"ruleId":"36","severity":1,"message":"40","line":130,"column":11,"nodeType":"38","messageId":"39","endLine":130,"endColumn":21},{"ruleId":"41","severity":1,"message":"42","line":136,"column":1,"nodeType":"43","endLine":136,"endColumn":90},"no-native-reassign",["44"],"no-negated-in-lhs",["45"],["44"],["45"],"no-unused-vars","'arrayBars' is assigned a value but never used.","Identifier","unusedVar","'animations' is assigned a value but never used.","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]